<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on keepSTEEP</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/</link><description>Recent content in Posts on keepSTEEP</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Mon, 12 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://oudon-mizusawa.github.io/keepSTEEP/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>集合指向的なアプリケーション設定</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/005/</link><pubDate>Mon, 12 Jan 2026 00:00:00 +0000</pubDate><guid>https://oudon-mizusawa.github.io/keepSTEEP/posts/005/</guid><description>はじめに 見出しへのリンク Smart data structures and dumb code works a lot better than the other way around.&amp;#34;(賢いデータ構造と愚かなコードは、その逆よりもずっとうまく機能する) という言葉があるように、優れたデータ構造を設計することはソフトウェア開発において重要である。ところが実務で様々な現場を経験すると、手続き型・関数型・オブジェクト指向といったプログラミングパラダイムやオニオンアーキテクチャなどのアーキテクチャにばかり注目が集まり、データ構造をいかにしてアプリケーションサーバに適用するかという視点が欠けていることが多いように思う。個人的な備忘録としてどのようにデータ構造を設計し、アプリケーションに適用するか一考する。
今回扱う範囲について 見出しへのリンク 一般的なアプリケーションサーバを対象とする データの取得はRDBを前提とする TypeScript/JavaScriptを使用する フレームワークは特に問わない 参考文献 見出しへのリンク プログラマのためのSQL 第4版
集合指向的なデータ構造設計 見出しへのリンク アプリケーションサーバにおけるデータ構造設計において重要なのは、データを「集合」として捉えることである。例えば、ユーザ情報を扱う場合、単一のユーザオブジェクトではなく、ユーザの集合を表現するデータ構造を設計する。これにより、データの一貫性を保ちやすくなり、操作も効率的になる。プログラミングとは手続きとデータの組み合わせであるが、データを集合として捉えることで、手続きも集合操作に基づいたものとなり、コードの可読性と保守性が向上する。
その良い例としてSQLを例に挙げる。SQLはデータ宣言言語（Data Declaration Language）・DML：データ操作言語（Data Manipulation Language）・DCL：データ制御言語（Data Control Language）の3つの要素から成り立っている。 SQLにおいては、データは常に集合として扱われ、単一のレコードを操作する場合でも、集合操作の一部として捉えられる。このように、データを集合として捉えることで、データの整合性を保ちつつ、効率的な操作が可能となる。
例えばSQLでユーザーに対するアクセスを手続き的に記述する場合、以下のようになる。
-- 手続き型: 1行ずつ処理(遅い、複雑) CREATE PROCEDURE GetActiveUsers() BEGIN DECLARE done INT DEFAULT FALSE; DECLARE user_id INT; DECLARE user_name VARCHAR(100); DECLARE is_active BOOLEAN; -- カーソル宣言 DECLARE user_cursor CURSOR FOR SELECT id, name, is_active FROM users; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; -- 結果格納用の一時テーブル CREATE TEMPORARY TABLE active_users ( id INT, name VARCHAR(100) ); OPEN user_cursor; read_loop: LOOP FETCH user_cursor INTO user_id, user_name, is_active; IF done THEN LEAVE read_loop; END IF; -- 1行ずつ条件チェック IF is_active = TRUE THEN INSERT INTO active_users (id, name) VALUES (user_id, user_name); END IF; END LOOP; CLOSE user_cursor; -- 結果を返す SELECT * FROM active_users; DROP TEMPORARY TABLE active_users; END; 集合指向的に記述する場合、以下のようになる。</description></item><item><title>Ubuntu OS バージョン偽装方法</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/004/</link><pubDate>Mon, 11 Mar 2024 00:00:00 +0000</pubDate><guid>https://oudon-mizusawa.github.io/keepSTEEP/posts/004/</guid><description>NAME=&amp;#34;Ubuntu&amp;#34; VERSION=&amp;#34;20.04 LTS (Focal Fossa)&amp;#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&amp;#34;Ubuntu 20.04 LTS&amp;#34; VERSION_ID=&amp;#34;20.04&amp;#34; HOME_URL=&amp;#34;https://www.ubuntu.com/&amp;#34; SUPPORT_URL=&amp;#34;https://help.ubuntu.com/&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34; PRIVACY_POLICY_URL=&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal のようになっているのを
NAME=&amp;#34;Ubuntu&amp;#34; VERSION=&amp;#34;20.04 LTS (Focal Fossa)&amp;#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&amp;#34;Ubuntu 20.04 LTS&amp;#34; VERSION_ID=&amp;#34;18.04&amp;#34; # 変更 HOME_URL=&amp;#34;https://www.ubuntu.com/&amp;#34; SUPPORT_URL=&amp;#34;https://help.ubuntu.com/&amp;#34; BUG_REPORT_URL=&amp;#34;https://bugs.launchpad.net/ubuntu/&amp;#34; PRIVACY_POLICY_URL=&amp;#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&amp;#34; VERSION_CODENAME=focal UBUNTU_CODENAME=focal https://qiita.com/hama6767/items/2351cf1f7f57bddd9f2a</description></item><item><title>Androidのヒープ領域</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/001/</link><pubDate>Sat, 09 Mar 2024 00:00:00 +0000</pubDate><guid>https://oudon-mizusawa.github.io/keepSTEEP/posts/001/</guid><description>Linux ヒープ 搭載されている物理的なRAMの全領域を扱って、android OS 全体に使われる。OS やカーネルに割り当てられるメモリの他に、以下のアプリケーションヒープも含まれる。 アプリケーションヒープ 各アプリケーション毎に OS によって割り当てられるメモリ領域で、多くの機種でデフォルトで 16MB ほど。JDK で作られたアプリケーションはこのメモリを使う。このヒープも大きく分けて２種類に分類される。 Dalvik (Java) ヒープ: Dalvik (Java) が使う変数などを配置するメモリ。 ネイティブヒープ: Bitmap などのリソースで扱うメモリ。 参考</description></item><item><title>Linux VPN周りのトンネリングってどの辺で実装してるの？</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/002/</link><pubDate>Sat, 09 Mar 2024 00:00:00 +0000</pubDate><guid>https://oudon-mizusawa.github.io/keepSTEEP/posts/002/</guid><description>TUN/TAPと呼ばれる仮想NICで実現しているらしい。
ここで湧いてくる疑問は、「なぜ、tun/tupの仮想インターネットデバイスを作ると全ての通信がそこ経由になるのか？」ということになるが、その辺はここに詳しく書いてある。</description></item><item><title>nmapの使い方</title><link>https://oudon-mizusawa.github.io/keepSTEEP/posts/003/</link><pubDate>Sat, 09 Mar 2024 00:00:00 +0000</pubDate><guid>https://oudon-mizusawa.github.io/keepSTEEP/posts/003/</guid><description>こちらを参考に以下まとめ。
隣接した複数のホストから成るネットワーク全体をスキャン対象としたい場合は、CIDR表記のアドレス指定を利用 Admin権限やroot権限を使ってnmapを使う必要がある。これは、ARP要求などはUNIXシステムなどにおいては、root権限が必要だからである。 SYN Scanはスキャン速度が早く、TCPコネクションを確立しないので秘匿性が高い。但し、知らないSYNパケットを捨てるといった処理をするデバイスに対しては効果がなかったりするので注意 OSのフィンガープリントの採取方法としては、例えばftpへの接続などを行い、そこで返された応答などから特定のOSかどうかをnmapが持っているDBと突合させるなどがある。</description></item></channel></rss>